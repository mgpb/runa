class UnwEx:
	ehid: uint
	clean: &byte
	priv1: uint
	priv2: uint

class Exception:
	
	header: UnwEx
	msg: $str
	
	def __init__(self, msg: $str):
		self.msg = msg

class LSDA:
	
	start: &byte
	lpstart: &byte
	ttype_base: &byte
	actions: &byte
	ttype_encoding: byte
	call_site_encoding: byte
	
	def __init__(self):
		pass

def _Unwind_GetLanguageSpecificData(ctx: lump[byte]) -> lump[byte]?
def _Unwind_GetTextRelBase(ctx: lump[byte]) -> u64
def _Unwind_GetDataRelBase(ctx: lump[byte]) -> u64
def _Unwind_GetRegionStart(ctx: lump[byte]) -> u64

def base_of_encoded_value(encoding: u8, ctx: lump[byte]) -> u64:
	
	print('BASE-OF-ENCODED-VALUE')
	if encoding == 255: # DW_EH_PE_omit
		return 0
	
	type = encoding & 112
	if type == 0: # DW_EH_PE_absptr
		return 0
	elif type == 16: # DW_EH_PE_pcrel
		return 0
	elif type == 80: # DW_EH_PE_aligned
		return 0
	elif type == 32: # DW_EH_PE_textrel
		return _Unwind_GetTextRelBase(ctx)
	elif type == 48: # DW_EH_PE_datarel
		return _Unwind_GetDataRelBase(ctx)
	elif type == 64: # DW_EH_PE_funcrel
		return _Unwind_GetRegionStart(ctx)
	else:
		return 0 # ABORT here

def read_encoded_value_with_base(encoding: u8, base: u64, p: lump[byte]) -> lump[byte]:
	print('READ-ENCODED-VALUE-WITH-BASE')
	print(encoding)
	result = 0 as i32
	if encoding == 80: # DW_EH_PE_aligned
		print('aligned')
	elif encoding & 15 == 0: # DW_EH_PE_absptr
		print('absptr')
	elif encoding & 15 == 1: # DW_EH_PE_uleb128
		print('uleb128')
	elif encoding & 15 == 9: # DW_EH_PE_sleb128
		print('sleb128')
	elif encoding & 15 == 2: # DW_EH_PE_udata2
		print('udata2')
	elif encoding & 15 == 3: # DW_EH_PE_udata4
		print('udata4')
	elif encoding & 15 == 4: # DW_EH_PE_udata8
		print('udata8')
	elif encoding & 15 == 10: # DW_EH_PE_sdata2
		print('sdata2')
	elif encoding & 15 == 11: # DW_EH_PE_sdata4
		print('sdata4')
		result = (p as lump[i32])[0]
		p = p.offset(4)
		print(result)
	elif encoding & 15 == 12: # DW_EH_PE_sdata8
		print('sdata8')
	else:
		result = 0
	
	return p

def read_encoded_value(ctx: lump[byte], encoding: u8, p: lump[byte]) -> lump[byte]:
	print('READ-ENCODED-VALUE')
	print(encoding & 15)
	read_encoded_value_with_base(encoding, base_of_encoded_value(encoding, ctx), p)
	return p

def parse_lsda_header(ctx: lump[byte], p: lump[byte]) -> ($LSDA, lump[byte]):
	
	info = LSDA()
	info.start = p[0]
	
	p = p.offset(1)
	start_encoding = p
	p = p.offset(1)
	if start_encoding[0] as &u8 != 255: # DW_EH_PE_omit
		read_encoded_value(ctx, start_encoding[0] as &u8, p)
	else:
		info.lpstart = info.start
	
	return info, p

def __runa_personality(v: i32, a: i32, cls: uint, h: &UnwEx, ctx: lump[byte]) -> i32:
	
	print('VERSION')
	print(v)
	if v != 1:
		return 3 # _URC_FATAL_PHASE1_ERROR
	
	print('ACTION')
	print(a)
	
	foreign = cls != 19507889121949010 # 'RunaRNE\x00'
	print('FOREIGN')
	print(foreign)
	
	lsd = _Unwind_GetLanguageSpecificData(ctx)
	if lsd is None:
		print('no LSD')
		return 8 # _URC_CONTINUE_UNWIND
	
	lsd_info, p = parse_lsda_header(ctx, lsd)
	return 3 # _URC_FATAL_PHASE1_ERROR
